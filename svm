from sklearn.preprocessing import MinMaxScaler
from torch.autograd import Variable
import matplotlib.pyplot as plt
import torch.nn.functional as F
import torch.nn as nn
import pandas as pd
import numpy as np
import torch

batch_size = 64

def logloss(y,y_pred):
    n = y.shape[0]
    res = np.zeros(shape=(n,))
    y_one_hot = np.eye(10)[y.astype(np.int32)]
    for i in range(n):
        res[i] = np.dot(y_one_hot[i][1:10],y_pred[i])
    return -torch.mean(torch.from_numpy(res))

def data_process(X,y,test_data):
    # normalize
    scaler = MinMaxScaler()                                               
    X_ = scaler.fit_transform(X)
    test_data_ = scaler.fit_transform(test_data)
    return X_,y,test_data_

def get_data():
    train_data = np.genfromtxt(open("./train.csv","rb"),delimiter=",")
    test_data = np.genfromtxt(open("./test.csv","rb"),delimiter=",")
    train_data = train_data[1:61879,1:95]
    test_data = test_data[1:144369,1:94]
    X,y = train_data[:,:93],train_data[:,93]
    return data_process(X,y,test_data)

class Net(torch.nn.Module):
    def __init__(self,n_input,n_hidden,n_output):
        super(Net,self).__init__()
        self.fc1 = torch.nn.Linear(n_input,n_hidden)
        self.fc2 = torch.nn.Linear(n_hidden,n_hidden)
        self.fc3 = torch.nn.Linear(n_hidden,n_output)
        self.sf = torch.nn.Softmax(dim=1)

    def forward(self, input):
        out = self.fc1(input)
        out = F.relu(out)
        out = self.fc2(out)
        out = F.relu(out)
        out = self.fc3(out)
        return self.sf(out)

def nn_run():
    X,y,test_data = get_data()
    net = Net(93,128,9)
    optimizer = torch.optim.Adam(net.parameters(), lr=0.001)
    # loss_func = torch.nn.CrossEntropyLoss()
    loss_func = torch.nn.MSELoss()
    loss_list = []
    for epoch in range(5):
        for i in range(X.shape[0]//batch_size):
            sample_index = np.random.choice(X.shape[0], batch_size)
            x_train = X[sample_index,:]
            y_train = np.eye(10)[y[sample_index].astype(np.int32)]
            y_train = torch.FloatTensor(y_train[:,1:10])
            y_pred = net(torch.FloatTensor(x_train))
            loss = loss_func(y_train,y_pred)
            loss_list.append(loss.item())
            # bp
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
    # plot
    x = np.arange(0,len(loss_list),1)
    y = np.array(loss_list)
    plt.plot(x,y)
    plt.savefig('./nn_loss.png')
    # save data
    y_pred = net(torch.FloatTensor(test_data)).detach().numpy()
    pred_data = {'id':[i for i in range(1,144369)]}
    for i in range(9):
        pred_data["Class_"+str(i+1)] = y_pred[:,i]
    data_df = pd.DataFrame(pred_data)
    data_df.to_csv('submit_nn.csv',index=False)

nn_run()
